<?php

namespace Banking\Services\Auth;

use Illuminate\Support\Str;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;
use Banking\Services\Contracts\BaasDigitalSignature;


/**
 * This class is responsible for creating and validating digital signatures for BaaS transactions.
 *
 * @property string $signature The digital signature generated by the `signature()` method.
 * @property $validateSignature The digital signature generated by the `validate()` method.
 */
class BaasSignature implements BaasDigitalSignature
{

    /**
     * Generates a signed body for the given transaction ID, timestamp and parameters.
     *@param string $transactionId The transaction ID.

     *@param array $params The parameters.

     *@return array The signed body.
     */
    public function signedBody(string $transactionId, array $params = [])
    {
        //remove middlename from the array
        if (!$params['middleName']) {
          unset($params['middleName']);
        }
        // Construct the data array with the required fields and random salt
        $data = [
            "locale" => "en_KE",
            "sender" => config('baas.baas_id.sender'),
            "requestId" => $transactionId,
            "timestamp" => now()->getTimestampMs(),
            "salt" => Str::random(20),
            "params" => $params
        ];
        $data['senderKey'] = config('baas.baas_id.senderKey');
        Log::alert($this->convertToStringPair($data));
        // Generate the signature using the sorted data array
        $this->signature = hash('sha256', $this->convertToStringPair($data));
        // Remove the senderKey field from the data array and add the signature field
        unset($data["senderKey"]);
        $data["signature"] = $this->signature;
        // Return the signed body
        return $data;
    }
    /**
     * Validates the digital signature for the BaaS transaction with the given ID.
     *
     * @param string $transactionId The ID of the BaaS transaction.
     * @param string $sign The digital signature to validate.
     *
     * @return bool True if the digital signature is valid, false otherwise.
     */
    public function isValidateSignature(string $response): bool
    {
        // Replace this example data with actual response data from the BaaS provider
        $data = (array)json_decode($response, true);
        $sharedHash = $data["signature"];
        unset($data["signature"]);
        $data['senderKey'] = config('baas.baas_id.senderKey');
        $responseSign = hash('sha256', $this->convertToStringPair($data));
        Log::alert($this->convertToStringPair($data));
        return hash_equals($sharedHash, $responseSign);
    }

    /**
     * Stores the digital signature for the BaaS transaction with the given ID in the cache.
     *
     * @param string $transactionId The ID of the BaaS transaction.
     *
     * @return bool True if the digital signature was successfully stored in the cache, false otherwise.
     */
    public function store(string $transactionId): bool
    {
        return Cache::put($transactionId, $this->signature, now()->addMinutes(10));
    }

    /**
     * Retrieves the digital signature for the BaaS transaction with the given ID from the cache.
     *
     * @param string $transactionId The ID of the BaaS transaction.
     *
     * @return string|null The digital signature for the BaaS transaction, or null if it was not found in the cache.
     */
    public function retrieve(string $transactionId): string|null
    {
        return Cache::get($transactionId);
    }

    /**
     *Convert multidimensional array to a string pair without encoding in PHP.
     *@param array $data The multidimensional array to be converted to string pair.
     *@param string $prefix Optional. The prefix to be added to the keys of the array. Default is an empty string.
     *@return string Returns the string pair representation of the array.
     */
    function convertToStringPair(array $data, $prefix = ''): string
    {
        // Sort the data array by key
        ksort($data);
        $str = '';
        foreach ($data as $key => $value) {
            // If the value is an array, recursively call the function with the updated prefix
            if (is_array($value)) {
                if (empty($value)) {
                    $str .= $prefix . $key . '={}' . '&';
                } else {
                    $str .= $this->convertToStringPair($value, $prefix . $key . '.') . '&';
                }
            }
            // If the value is not null, add it to the string pair
            elseif ($value !== null) {
                $str .= $prefix . $key . '=' . $value . '&';
            }
            // If the value is null, add the key with empty value to the string pair
            else {
                $str .= $prefix . $key . '=&';
            }
        }
        // Remove the trailing '&' character and return the string pair
        return rtrim($str, '&');
    }
}
